generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model subscriber {
  id                         String                  @id @default(cuid())
  company_name               String                  @unique
  display_name               String
  api_key                    String                  @unique @default(cuid())
  active                     Boolean                 @default(false)
  created_at                 DateTime                @default(now()) @db.Timestamp(6)
  updated_at                 DateTime                @default(now()) @db.Timestamp(6)
  subscriber_subscription    subscriber_subscription @relation(fields: [subscriber_subscription_id], references: [id])
  subscriber_subscription_id String
  ai                         subscriber_ai?
  roles                      role[]
  extra_permissions          extra_permission[]
  users                      user[]
  socket_sessions            socket_session[]
  conversations              conversation[]
  messages                   message[]
  conversation_sessions      conversation_session[]
  intents                    intent[]
  intent_actions             intent_action[]
  speech_recognitions        speech_recognition[]
  chat_departments           chat_department[]
  chat_templates             chat_template[]
  user_invitations           user_invitation[]
  user_settings              user_setting_value[]
  settings                   setting[]
  attachments                attachment[]
}

model subscriber_ai {
  id            String     @id @default(cuid())
  access_token  String
  app_id        String
  app_name      String
  subscriber    subscriber @relation(fields: [subscriber_id], references: [id])
  subscriber_id String     @unique
}

model subscription {
  id                         String                      @id @default(cuid())
  slug                       String                      @unique
  display_name               String
  one_day_price              Int
  active                     Boolean                     @default(false)
  subscriber_subscriptions   subscriber_subscription[]
  package_element_values     package_element_value[]
  subscription_days_to_names subscription_days_to_name[]
}

model subscriber_subscription {
  id              String       @id @default(cuid())
  created_at      DateTime     @default(now()) @db.Timestamp(6)
  updated_at      DateTime     @default(now()) @db.Timestamp(6)
  subscriber      subscriber?
  subscription    subscription @relation(fields: [subscription_id], references: [id])
  subscription_id String
}

model subscription_days_to_name {
  id              String       @id @default(cuid())
  subscription    subscription @relation(fields: [subscription_id], references: [id])
  subscription_id String
  days_to_name    days_to_name @relation(fields: [days_to_name_id], references: [id])
  days_to_name_id String
  price           Int?
}

// each subscription package element
model package_element {
  id            String                 @id @default(cuid())
  slug          String
  display_name  String
  value         package_element_value?
  static        Boolean                @default(false)
  ui_visibility Boolean                @default(true)
  active        Boolean                @default(false)
}

// will be use in all the subscription packages if not changed individually
model package_element_value {
  id              String          @id @default(cuid())
  element         package_element @relation(fields: [element_id], references: [id])
  element_id      String
  subscription    subscription    @relation(fields: [subscription_id], references: [id])
  subscription_id String
}

model days_to_name {
  id                        String                      @id @default(cuid())
  slug                      String
  display_name              String
  in_days                   Int
  subscription_days_to_name subscription_days_to_name[]
}

model user_invitation {
  id            String                      @id @default(cuid())
  email         String
  code          String
  type          user_invitation_type_enum
  status        user_invitation_status_enum @default(pending)
  active        Boolean                     @default(true)
  created_at    DateTime                    @default(now()) @db.Timestamp(6)
  updated_at    DateTime                    @default(now()) @db.Timestamp(6)
  subscriber    subscriber                  @relation(fields: [subscriber_id], references: [id])
  subscriber_id String
}

model user {
  id                String               @id @default(cuid())
  email             String               @db.VarChar
  password          String               @db.VarChar
  active            Boolean              @default(false)
  online_status     Boolean              @default(true)
  created_at        DateTime             @default(now()) @db.Timestamp(6)
  updated_at        DateTime             @default(now()) @db.Timestamp(6)
  user_meta         user_meta?
  subscriber        subscriber           @relation(fields: [subscriber_id], references: [id])
  subscriber_id     String
  role              role                 @relation(fields: [role_id], references: [id])
  role_id           String
  extra_permissions extra_permission[]
  socket_sessions   socket_session[]
  chat_departments  chat_department[]
  chat_templates    chat_template[]
  settings          user_setting_value[]

  @@unique(fields: [email, subscriber_id], name: "user_identifier")
}

model user_meta {
  id           String   @id @default(cuid())
  full_name    String   @db.VarChar
  display_name String
  created_at   DateTime @default(now()) @db.Timestamp(6)
  updated_at   DateTime @default(now()) @db.Timestamp(6)
  user         user?    @relation(fields: [user_id], references: [id])
  user_id      String?
}

model setting {
  id                  String                      @id @default(cuid())
  slug                String
  display_name        String
  description         String?
  default_value       String?
  category            settings_category_type_enum @default(any)
  sub_category        String?
  input_type          settings_input_type_enum    @default(text)
  created_at          DateTime                    @default(now()) @db.Timestamp(6)
  updated_at          DateTime                    @default(now()) @db.Timestamp(6)
  user_type           setting_user_type_enum // it will determine where n which page to show
  subscriber          subscriber?                 @relation(fields: [subscriber_id], references: [id])
  subscriber_id       String? // subscriber ? then its only for this subscriner else for all
  user_settings_value user_setting_value[]

  @@unique(fields: [slug, category, user_type], name: "slug_identifier")
}

model user_setting_value {
  id            String      @id @default(cuid())
  value         String
  created_at    DateTime    @default(now()) @db.Timestamp(6)
  updated_at    DateTime    @default(now()) @db.Timestamp(6)
  user          user?       @relation(fields: [user_id], references: [id])
  user_id       String? // not user ? then for subscriber
  subscriber    subscriber? @relation(fields: [subscriber_id], references: [id])
  subscriber_id String? // not subscriber ? thne for administrator
  setting       setting?    @relation(fields: [setting_id], references: [id])
  setting_id    String?
}

model role {
  id            String            @id @default(cuid())
  use_for       role_use_for_enum @default(subscriber)
  slug          String            @db.VarChar
  name          String            @db.VarChar
  description   String?           @db.VarChar
  created_at    DateTime          @default(now()) @db.Timestamp(6)
  updated_at    DateTime          @default(now()) @db.Timestamp(6)
  subscriber    subscriber?       @relation(fields: [subscriber_id], references: [id])
  subscriber_id String?
  users         user[]
  permissions   permission[]
}

model permission {
  id                String                  @id @default(cuid())
  use_for           permission_use_for_enum @default(subscriber)
  slug              String                  @unique @db.VarChar
  name              String                  @db.VarChar
  description       String?                 @db.VarChar
  status            Boolean                 @default(true)
  created_at        DateTime                @default(now()) @db.Timestamp(6)
  updated_at        DateTime                @default(now()) @db.Timestamp(6)
  roles             role[]
  extra_permissions extra_permission[]
}

model extra_permission {
  id            String      @id @default(cuid())
  created_at    DateTime    @default(now()) @db.Timestamp(6)
  updated_at    DateTime    @default(now()) @db.Timestamp(6)
  subscriber    subscriber? @relation(fields: [subscriber_id], references: [id])
  subscriber_id String? // if has then all the users in this subscriber
  permission    permission  @relation(fields: [permission_id], references: [id])
  permission_id String
  user          user?       @relation(fields: [user_id], references: [id])
  user_id       String?
  // administrator user pending
  include       Boolean     @default(true)
}

model socket_session {
  id                    String                 @id @default(cuid())
  info                  String?                @db.VarChar
  ip                    String                 @db.VarChar
  identifier            String?                @db.VarChar // it will determine by which key we can get the user logged info from api
  init_name             String?                @db.VarChar
  init_email            String?                @db.VarChar
  //   user_type           socket_session_user_type_enum @default(client)
  created_at            DateTime               @default(now()) @db.Timestamp(6)
  updated_at            DateTime               @default(now()) @db.Timestamp(6)
  subscriber_id         String
  subscriber            subscriber             @relation(fields: [subscriber_id], references: [id])
  user_id               String?
  user                  user?                  @relation(fields: [user_id], references: [id])
  conversation_sessions conversation_session[]
  created_conversations conversation[]         @relation(name: "created_by")
  closed_conversations  conversation[]         @relation(name: "closed_by")
  messages              message[]
  attachments           attachment[]
}

model conversation {
  id                    String                 @id @default(cuid())
  users_only            Boolean?
  type                  conversation_type_enum @default(user_to_user_chat)
  ai_is_replying        Boolean                @default(false)
  closed_at             DateTime?              @db.Timestamp(6)
  created_at            DateTime               @default(now()) @db.Timestamp(6)
  updated_at            DateTime               @default(now()) @db.Timestamp(6)
  subscriber_id         String
  subscriber            subscriber             @relation(fields: [subscriber_id], references: [id])
  created_by_id         String
  created_by            socket_session         @relation(name: "created_by", fields: [created_by_id], references: [id])
  closed_by_id          String?
  closed_by             socket_session?        @relation(name: "closed_by", fields: [closed_by_id], references: [id])
  chat_department_id    String?
  chat_department       chat_department?       @relation(fields: [chat_department_id], references: [id])
  conversation_sessions conversation_session[]
  messages              message[]
}

model conversation_session {
  id                String         @id @default(cuid())
  joined_at         DateTime?      @db.Timestamp(6)
  left_at           DateTime?      @db.Timestamp(6)
  created_at        DateTime       @default(now()) @db.Timestamp(6)
  updated_at        DateTime       @default(now()) @db.Timestamp(6)
  socket_session    socket_session @relation(fields: [socket_session_id], references: [id])
  socket_session_id String
  conversation      conversation   @relation(fields: [conversation_id], references: [id])
  conversation_id   String
  subscriber_id     String
  subscriber        subscriber     @relation(fields: [subscriber_id], references: [id])

  @@unique(fields: [conversation_id, socket_session_id], name: "conv_ses_identifier")
}

model message {
  id                String          @id @default(cuid())
  msg               String?
  created_at        DateTime        @default(now()) @db.Timestamp(6)
  updated_at        DateTime        @default(now()) @db.Timestamp(6)
  attachments       attachment[]
  conversation_id   String
  conversation      conversation    @relation(fields: [conversation_id], references: [id])
  subscriber_id     String
  subscriber        subscriber      @relation(fields: [subscriber_id], references: [id])
  socket_session_id String?
  socket_session    socket_session? @relation(fields: [socket_session_id], references: [id])
}

model attachment {
  id                String          @id @default(cuid())
  original_name     String
  uploaded          Boolean         @default(false)
  size              Int             @default(0) @db.Integer
  user_has_control  Boolean         @default(true) // if false user deleted from uploads list but msg can resolve
  created_at        DateTime        @default(now()) @db.Timestamp(6)
  updated_at        DateTime        @default(now()) @db.Timestamp(6)
  messages          message[]
  subscriber_id     String
  subscriber        subscriber      @relation(fields: [subscriber_id], references: [id])
  socket_session_id String?
  socket_session    socket_session? @relation(fields: [socket_session_id], references: [id])
}

model speech_recognition {
  id                 String      @id @default(cuid())
  speech             String
  forced             Boolean     @default(false)
  confidence         Float       @default(0.0000)
  resolved           Boolean     @default(false) // after submit get the result
  has_in_ai          Boolean     @default(false) // submitted to ai
  submit_to_ai       Boolean     @default(false) // submit to ai
  remove_from_ai     Boolean     @default(false) // it will handle removing speech from ai. [after remove has_in_ai to false(sys)]
  active             Boolean     @default(false)
  ai_last_checked_at DateTime?   @db.Timestamp(6) // check confidence time to time
  for_delete         Boolean     @default(false)
  created_at         DateTime    @default(now()) @db.Timestamp(6)
  updated_at         DateTime    @default(now()) @db.Timestamp(6)
  script_name        String?
  script_status      String?
  script_updated_at  DateTime?   @db.Timestamp(6)
  tsid               String      @default("") // temp_subscriber_Id. its only for unique check. cz relation can be null
  subscriber_id      String?
  subscriber         subscriber? @relation(fields: [subscriber_id], references: [id])
  intent_id          String?
  intent             intent?     @relation(fields: [intent_id], references: [id])

  @@unique(fields: [speech, tsid, for_delete], name: "speech_subscriber_delete")
}

model intent {
  id                 String               @id @default(cuid())
  tag                String
  description        String
  active             Boolean              @default(false)
  submit_to_ai       Boolean              @default(true)
  remove_from_ai     Boolean              @default(false)
  ai_id              String?
  for_delete         Boolean              @default(false)
  created_at         DateTime             @default(now()) @db.Timestamp(6)
  updated_at         DateTime             @default(now()) @db.Timestamp(6)
  script_name        String?
  script_status      String?
  script_updated_at  DateTime?            @db.Timestamp(6)
  subscriber_id      String?
  subscriber         subscriber?          @relation(fields: [subscriber_id], references: [id])
  intent_action      intent_action?
  speech_recognition speech_recognition[]
  chat_templates     chat_template[]
}

model intent_action {
  id            String             @id @default(cuid())
  type          intent_action_type
  content       String?
  action_name   String?
  external_path String?
  created_at    DateTime           @default(now()) @db.Timestamp(6)
  updated_at    DateTime           @default(now()) @db.Timestamp(6)
  subscriber_id String?
  subscriber    subscriber?        @relation(fields: [subscriber_id], references: [id])
  intent_id     String
  intent        intent             @relation(fields: [intent_id], references: [id])
}

model chat_template {
  id                 String           @id @default(cuid())
  tag                String
  description        String
  content            String? // if no intent then content will kick in
  is_action          Boolean          @default(false) // if true will try chat_template_action (wip)
  active             Boolean          @default(false)
  created_at         DateTime         @default(now()) @db.Timestamp(6)
  updated_at         DateTime         @default(now()) @db.Timestamp(6)
  chat_department_id String?
  chat_department    chat_department? @relation(fields: [chat_department_id], references: [id])
  subscriber_id      String?
  subscriber         subscriber?      @relation(fields: [subscriber_id], references: [id])
  user_id            String?
  user               user?            @relation(fields: [user_id], references: [id])
  intent_id          String?
  intent             intent?          @relation(fields: [intent_id], references: [id])
}

model chat_department {
  id             String          @id @default(cuid())
  tag            String
  description    String
  active         Boolean         @default(true)
  created_at     DateTime        @default(now()) @db.Timestamp(6)
  updated_at     DateTime        @default(now()) @db.Timestamp(6)
  subscriber_id  String
  subscriber     subscriber      @relation(fields: [subscriber_id], references: [id])
  users          user[]
  chat_templates chat_template[]
  conversations  conversation[]
}

enum permission_use_for_enum {
  subscriber
  administrator
}

enum role_use_for_enum {
  subscriber
  administrator
}

enum user_invitation_status_enum {
  pending
  expired
  cancelled
  success
}

enum user_invitation_type_enum {
  user
  agent
}

enum socket_session_user_type_enum {
  client
  user
}

enum conversation_type_enum {
  live_chat
  user_to_user_chat
  group_chat
}

enum intent_action_type {
  action
  static
  external
}

enum setting_user_type_enum {
  all
  user
  subscriber
  administrator
}

enum settings_category_type_enum {
  any
  ui
  app
}

enum settings_input_type_enum {
  text
  password
}
